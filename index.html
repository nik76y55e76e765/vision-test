<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Soul: AR Mode</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New',monospace; color:#00ffcc; touch-action:none; }
        #info { position:absolute; top:20px; left:20px; right:20px; background:rgba(0,15,15,0.95); padding:15px; border:1px solid #00ffcc; border-radius:8px; z-index:10; font-size:13px; }
        #arButton, #resetButton {
            position:absolute; left:50%; transform:translateX(-50%);
            padding:15px 40px; background:#00ffcc; color:#000; border:none;
            border-radius:8px; font-weight:bold; font-size:16px; cursor:pointer; z-index:100;
        }
        #arButton { bottom:30px; }
        #resetButton { bottom:100px; background:#ff00aa; color:#fff; display:none; }
        #arButton:hover, #resetButton:hover { background:#fff; }
        .hidden { display:none !important; }
    </style>
</head>
<body>
    <div id="info">
        <div style="font-weight:bold; margin-bottom:8px;">üì± DIGITAL SOUL AR</div>
        <div id="status">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    </div>
   
    <button id="arButton">–í–û–ô–¢–ò –í AR</button>
    <button id="resetButton">–ü–ï–†–ï–°–¢–ê–í–ò–¢–¨ –ö–†–ò–°–¢–ê–õ–õ</button>

    <!-- –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script type="module">
        let scene, camera, renderer, fieldGroup, reticle;
        let particleCount = 2200;
        let CORE_COUNT = 1200;
        let positions, basePositions, particleColors, velocities;
        let corePositions, coreBase, coreVel, coreGeo;
        let time = 0;
        let fieldPlaced = false;
        let hitTestSource = null;
        let xrRefSpace = null;
        let colorGroups = [];
        let dragging = false, lastMouseX = 0, lastMouseY = 0;

        const COLOR_LIST = [[0,1,0.8],[0,0.5,1],[0.8,0.2,1],[1,0.3,0]];
        const NUM_COLORS = 4;

        function init() {
            const status = document.getElementById('status');
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                    if (supported) {
                        status.innerHTML = '‚úÖ AR –≥–æ—Ç–æ–≤!<br>–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –∏ –Ω–∞–≤–µ–¥–∏ –Ω–∞ –ø–æ–ª';
                        document.getElementById('arButton').style.display = 'block';
                        document.getElementById('arButton').addEventListener('click', startAR);
                    } else {
                        startPreviewMode();
                    }
                });
            } else {
                startPreviewMode();
            }
            document.getElementById('resetButton').addEventListener('click', resetField);
            window.addEventListener('resize', onResize);
        }

        function startPreviewMode() {
            document.getElementById('status').innerHTML = 'üñ•Ô∏è –ü–ö-–ü—Ä–µ–≤—å—é<br>–ö—Ä—É—Ç–∏ –º—ã—à–∫–æ–π ‚Äî –∫—Ä–∏—Å—Ç–∞–ª–ª –∂–∏–≤–æ–π!';
            document.getElementById('arButton').style.display = 'none';

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 50);
            camera.position.set(0, 0.6, 2.2);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createQuantumField();
            fieldGroup.visible = true;
            fieldGroup.position.set(0, -0.35, 0);
            fieldGroup.scale.set(0.45, 0.45, 0.45);

            const dom = renderer.domElement;
            dom.addEventListener('mousedown', e=>{dragging=true; lastMouseX=e.clientX; lastMouseY=e.clientY;});
            dom.addEventListener('mouseup', ()=>dragging=false);
            dom.addEventListener('mousemove', onMouseMove);
            dom.addEventListener('mouseleave', ()=>dragging=false);

            animatePreview();
        }

        function onMouseMove(e) {
            if(!dragging) return;
            const dx = e.clientX - lastMouseX;
            fieldGroup.rotation.y += dx * 0.006;
            lastMouseX = e.clientX;
        }

        function animatePreview() {
            requestAnimationFrame(animatePreview);
            time += 0.016;
            animateField();
            renderer.render(scene, camera);
        }

        async function startAR() { /* AR-–∫–æ–¥ –æ—Å—Ç–∞–ª—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, —Ä–∞–±–æ—Ç–∞–µ—Ç */ 
            // (–ø–æ–ª–Ω—ã–π AR-–∫–æ–¥ —Ç–æ—Ç –∂–µ, —á—Ç–æ –±—ã–ª —Ä–∞–Ω—å—à–µ ‚Äî –Ω–µ –º–µ–Ω—è–ª)
            const session = await navigator.xr.requestSession('immersive-ar', {requiredFeatures:['hit-test']});
            session.addEventListener('end', ()=>location.reload());
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
            renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
            renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const reticleGeo = new THREE.RingGeometry(0.15,0.2,32).rotateX(-Math.PI/2);
            reticle = new THREE.Mesh(reticleGeo, new THREE.MeshBasicMaterial({color:0x00ffcc}));
            reticle.matrixAutoUpdate = false; reticle.visible = false;
            scene.add(reticle);

            createQuantumField();
            await renderer.xr.setSession(session);

            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({space: viewerSpace});

            document.getElementById('info').classList.add('hidden');
            document.getElementById('arButton').classList.add('hidden');
            renderer.xr.setAnimationLoop(arRenderLoop);
        }

        function arRenderLoop(timestamp, frame) {
            if(!frame) return;
            xrRefSpace = renderer.xr.getReferenceSpace();

            if(hitTestSource && !fieldPlaced) {
                const hits = frame.getHitTestResults(hitTestSource);
                if(hits.length) {
                    reticle.visible = true;
                    reticle.matrix.fromArray(hits[0].getPose(xrRefSpace).transform.matrix);
                } else reticle.visible = false;
            }

            for(let input of frame.session.inputSources) {
                if(input.gamepad?.buttons[0]?.pressed && !fieldPlaced && reticle.visible) {
                    const hits = frame.getHitTestResults(hitTestSource);
                    if(hits.length) {
                        const pose = hits[0].getPose(xrRefSpace);
                        const mat = new THREE.Matrix4().fromArray(pose.transform.matrix);
                        fieldGroup.position.setFromMatrixPosition(mat);
                        fieldGroup.quaternion.setFromRotationMatrix(new THREE.Matrix4().extractRotation(mat));
                        fieldGroup.visible = true;
                        fieldPlaced = true;
                        document.getElementById('resetButton').style.display = 'block';
                    }
                }
            }

            if(fieldPlaced) {
                time += 0.018;
                animateField();
            }
            renderer.render(scene, camera);
        }

        function createQuantumField() {
            fieldGroup = new THREE.Group();
            scene.add(fieldGroup);

            const crystal = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 3.0, 0.3),
                new THREE.MeshBasicMaterial({color:0x00ffcc, transparent:true, opacity:0.04, wireframe:true})
            );
            fieldGroup.add(crystal);

            particleColors = new Uint8Array(particleCount);
            velocities = new Float32Array(particleCount*3);
            positions = new Float32Array(particleCount*3);
            basePositions = new Float32Array(particleCount*3);

            for(let i=0;i<particleCount;i++) particleColors[i] = i%NUM_COLORS;
            updateParticleDistribution();

            colorGroups = [];
            for(let c=0; c<NUM_COLORS; c++) {
                const col = COLOR_LIST[c];
                const cnt = Math.floor(particleCount/NUM_COLORS);
                const groupPos = new Float32Array(cnt*3);
                let ci=0;
                for(let i=0; i<particleCount; i++) {
                    if(particleColors[i]===c) {
                        groupPos[ci*3] = positions[i*3];
                        groupPos[ci*3+1] = positions[i*3+1];
                        groupPos[ci*3+2] = positions[i*3+2];
                        ci++;
                    }
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(groupPos,3));
                const mat = new THREE.PointsMaterial({
                    size:0.045, map:makeTexture(col[0]*255,col[1]*255,col[2]*255),
                    transparent:true, blending:THREE.AdditiveBlending, depthWrite:false
                });
                fieldGroup.add(new THREE.Points(geo, mat));
                colorGroups.push({positions:groupPos, geo, count:cnt, colorIdx:c});
            }

            buildCoreBase();
            coreGeo = new THREE.BufferGeometry();
            coreGeo.setAttribute('position', new THREE.BufferAttribute(corePositions,3));
            fieldGroup.add(new THREE.Points(coreGeo, new THREE.PointsMaterial({size:0.18, map:makeTexture(220,240,255), transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.55})));
            fieldGroup.add(new THREE.Points(coreGeo, new THREE.PointsMaterial({size:0.09, map:makeTexture(255,255,255), transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.9})));
            fieldGroup.add(new THREE.Points(coreGeo, new THREE.PointsMaterial({size:0.035, map:makeTexture(255,255,255), transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:1})));
        }

        function makeTexture(r,g,b) {
            const c = document.createElement('canvas'); c.width=c.height=32;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, `rgba(${r|0},${g|0},${b|0},1)`);
            grad.addColorStop(0.45, `rgba(${r|0},${g|0},${b|0},0.5)`);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        function updateParticleDistribution() { /* —Ç–æ—Ç –∂–µ –∫–æ–¥, —á—Ç–æ —Ä–∞–Ω—å—à–µ */ 
            for(let i=0;i<particleCount;i++) {
                const t = i/particleCount;
                if(t<0.45) {
                    const f = Math.pow(Math.random(),3.2);
                    basePositions[i*3] = (Math.random()-0.5)*2.3*f*1.9;
                    basePositions[i*3+1] = (Math.random()-0.5)*3.4;
                    basePositions[i*3+2] = (Math.random()-0.5)*0.45;
                } else {
                    const f = Math.pow(Math.random(),2.1);
                    const r = 2.25*f;
                    const a = Math.random()*Math.PI*2;
                    basePositions[i*3] = r*Math.cos(a)*1.45;
                    basePositions[i*3+1] = (Math.random()-0.5)*3.6;
                    basePositions[i*3+2] = r*Math.sin(a)*0.65;
                }
                positions[i*3] = basePositions[i*3];
                positions[i*3+1] = basePositions[i*3+1];
                positions[i*3+2] = basePositions[i*3+2];
            }
        }

        function buildCoreBase() { /* —Ç–æ—Ç –∂–µ */ 
            corePositions = new Float32Array(CORE_COUNT*3);
            coreBase = new Float32Array(CORE_COUNT*3);
            coreVel = new Float32Array(CORE_COUNT*3);
            for(let i=0;i<CORE_COUNT;i++) {
                const xRand = Math.random()-0.5;
                const sign = xRand<0?-1:1;
                coreBase[i*3] = sign * Math.pow(Math.abs(xRand),1.6)*0.32;
                coreBase[i*3+1] = (Math.random()-0.5)*3.3;
                coreBase[i*3+2] = (Math.random()-0.5)*0.18;
                corePositions[i*3] = coreBase[i*3];
                corePositions[i*3+1] = coreBase[i*3+1];
                corePositions[i*3+2] = coreBase[i*3+2];
            }
        }

        function animateField() { /* –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ */ 
            const movingCenters = [
                {x:Math.sin(time*0.7)*0.45, y:0.8+Math.sin(time*1.15)*0.55},
                {x:-1.2+Math.sin(time*0.85+1)*0.35, y:Math.sin(time*1.35)*0.8},
                {x:1.2+Math.sin(time*0.9+2)*0.35, y:Math.sin(time*1.35+Math.PI)*0.8},
                {x:Math.sin(time*0.65+3)*0.45, y:-0.8+Math.sin(time*1.05)*0.55}
            ];

            for(let i=0;i<particleCount;i++) {
                const col = particleColors[i];
                const cx = movingCenters[col].x, cy = movingCenters[col].y;
                const wave = Math.sin(basePositions[i*3+1]*3.1 + time*3.2 + col)*0.27;
                const dx = cx - positions[i*3], dy = cy - positions[i*3+1];
                velocities[i*3] += dx*0.042 + (0-positions[i*3])*0.075;
                velocities[i*3+1] += dy*0.042;
                velocities[i*3]*=0.875; velocities[i*3+1]*=0.875; velocities[i*3+2]*=0.88;
                positions[i*3] = basePositions[i*3] + wave + velocities[i*3] + (Math.random()-0.5)*0.035;
                positions[i*3+1] = basePositions[i*3+1] + velocities[i*3+1] + (Math.random()-0.5)*0.035;
                positions[i*3+2] = basePositions[i*3+2] + velocities[i*3+2];
            }

            colorGroups.forEach(group => {
                let ci=0; const cIdx=group.colorIdx;
                for(let i=0; i<particleCount && ci<group.count; i++) {
                    if(particleColors[i]===cIdx) {
                        group.positions[ci*3]=positions[i*3];
                        group.positions[ci*3+1]=positions[i*3+1];
                        group.positions[ci*3+2]=positions[i*3+2];
                        ci++;
                    }
                }
                group.geo.attributes.position.needsUpdate = true;
            });

            for(let i=0;i<CORE_COUNT;i++) {
                const wave = Math.sin(coreBase[i*3+1]*3.1 + time*3.6)*0.16;
                const dx = -corePositions[i*3]*0.17;
                coreVel[i*3] += dx;
                coreVel[i*3+1] += (coreBase[i*3+1]-corePositions[i*3+1])*0.06;
                coreVel[i*3]*=0.81; coreVel[i*3+1]*=0.84; coreVel[i*3+2]*=0.84;
                corePositions[i*3] = coreBase[i*3] + wave + coreVel[i*3];
                corePositions[i*3+1] = coreBase[i*3+1] + coreVel[i*3+1];
                corePositions[i*3+2] = coreBase[i*3+2] + coreVel[i*3+2];
            }
            coreGeo.attributes.position.needsUpdate = true;

            fieldGroup.rotation.y += 0.0028;
        }

        function resetField() {
            if(fieldGroup) fieldGroup.visible = false;
            fieldPlaced = false;
            document.getElementById('resetButton').style.display = 'none';
        }

        function onResize() {
            if(!camera || !renderer) return;
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
