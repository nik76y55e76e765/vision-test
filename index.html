<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Quest Energy Test</title>
<style>
  body { margin:0; overflow:hidden; }
</style>
</head>
<body>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/webxr/ARButton.js";

let camera, scene, renderer, energy;

init();

function init(){

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();

  renderer = new THREE.WebGLRenderer({
    antialias:true,
    alpha:true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  document.body.appendChild(
    ARButton.createButton(renderer, {
      requiredFeatures: ['local-floor']
    })
  );

  // Мягкий свет (чтобы не было чёрного)
  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  scene.add(light);

  createEnergyField();

  renderer.setAnimationLoop(render);
}

function createEnergyField(){

  const geometry = new THREE.SphereGeometry(0.3, 64, 64);

  const material = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    side: THREE.BackSide,
    uniforms: { time:{ value:0 }},
    vertexShader: `
      varying vec3 vWorld;
      void main(){
        vec4 worldPos = modelMatrix * vec4(position,1.0);
        vWorld = worldPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `,
    fragmentShader: `
      varying vec3 vWorld;
      uniform float time;

      float hash(vec3 p){
        return fract(sin(dot(p, vec3(127.1,311.7,74.7))) * 43758.5453);
      }

      float noise(vec3 p){
        vec3 i = floor(p);
        vec3 f = fract(p);
        f = f*f*(3.0-2.0*f);

        float n = mix(
          mix(
            mix(hash(i+vec3(0,0,0)), hash(i+vec3(1,0,0)), f.x),
            mix(hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)), f.x),
            f.y),
          mix(
            mix(hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)), f.x),
            mix(hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)), f.x),
            f.y),
          f.z);
        return n;
      }

      void main(){

        float structure = noise(vWorld * 0.6);

        float density = structure * 0.8;

        density += sin(time * 0.2) * 0.005;

        float fog = smoothstep(0.4, 0.75, density);

        vec3 color = vec3(0.82,0.83,0.85);

        gl_FragColor = vec4(color * fog, fog * 0.05);
      }
    `
  });

  energy = new THREE.Mesh(geometry, material);

  energy.position.set(0, 1.5, -1.2); // перед тобой
  scene.add(energy);
}

function render(time){

  if(energy){
    energy.material.uniforms.time.value = time * 0.001;
  }

  renderer.render(scene, camera);
}

</script>
</body>
</html>
