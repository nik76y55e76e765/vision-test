<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Soul - Quest AR</title>
    <style>
        body { 
            margin: 0;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #00ffcc;
            overflow: hidden;
        }
        
        #startScreen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            background: linear-gradient(135deg, #001a1a 0%, #000a0a 100%);
        }
        
        .title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 30px;
            text-align: center;
            letter-spacing: 3px;
        }
        
        .controls {
            width: 100%;
            max-width: 500px;
            background: rgba(0, 30, 30, 0.8);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid #00ffcc;
        }
        
        .control-item {
            margin-bottom: 25px;
        }
        
        .control-item label {
            display: block;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        
        .value {
            float: right;
            color: #fff;
            font-weight: bold;
        }
        
        input[type=range] {
            width: 100%;
            height: 40px;
            accent-color: #00ffcc;
        }
        
        #startButton {
            width: 100%;
            padding: 20px;
            margin-top: 30px;
            background: #00ffcc;
            color: #000;
            border: none;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        
        #startButton:hover {
            background: #00fff0;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }
        
        #startButton:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 100, 100, 0.3);
            border-radius: 8px;
            text-align: center;
            font-size: 13px;
        }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="startScreen">
        <div class="title">⚛️ DIGITAL SOUL</div>
        
        <div class="controls">
            <div class="control-item">
                <label>
                    Цветные частицы
                    <span class="value" id="vP">2000</span>
                </label>
                <input type="range" id="pCount" min="500" max="4000" step="100" value="2000">
            </div>
            
            <div class="control-item">
                <label>
                    Белое ядро
                    <span class="value" id="vC">1000</span>
                </label>
                <input type="range" id="cCount" min="100" max="2000" step="100" value="1000">
            </div>
            
            <div class="control-item">
                <label>
                    Притяжение
                    <span class="value" id="vA">0.5</span>
                </label>
                <input type="range" id="attract" min="0.0" max="1.0" step="0.1" value="0.5">
            </div>
            
            <div class="control-item">
                <label>
                    Размер
                    <span class="value" id="vS">0.4</span>
                </label>
                <input type="range" id="scale" min="0.1" max="1.0" step="0.1" value="0.4">
            </div>
            
            <button id="startButton">ЗАГРУЗКА...</button>
            
            <div class="status" id="status">
                Проверка AR поддержки...
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        // Параметры
        let particleCount = 2000;
        let CORE_COUNT = 1000;
        let attractStrength = 0.5;
        let objectScale = 0.4;
        
        // Three.js переменные
        let scene, camera, renderer;
        let crystal, reticle;
        let positions, basePositions, particleColors, velocities;
        let corePositions, coreBase, coreVel, coreGeo;
        let time = 0;
        
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let fieldPlaced = false;
        
        const COLOR_LIST = [
            [0.0, 1.0, 0.8],
            [0.0, 0.5, 1.0],
            [0.8, 0.2, 1.0],
            [1.0, 0.3, 0.0],
        ];
        const NUM_COLORS = COLOR_LIST.length;
        
        const attractCenters = [
            { x: 0.0, y: 0.8 },
            { x: -1.2, y: 0.0 },
            { x: 1.2, y: 0.0 },
            { x: 0.0, y: -0.8 },
        ];
        
        // UI элементы
        const pSlider = document.getElementById('pCount');
        const cSlider = document.getElementById('cCount');
        const aSlider = document.getElementById('attract');
        const sSlider = document.getElementById('scale');
        const startBtn = document.getElementById('startButton');
        const statusDiv = document.getElementById('status');
        
        // Обновление значений
        pSlider.oninput = () => {
            document.getElementById('vP').textContent = pSlider.value;
            particleCount = parseInt(pSlider.value);
        };
        cSlider.oninput = () => {
            document.getElementById('vC').textContent = cSlider.value;
            CORE_COUNT = parseInt(cSlider.value);
        };
        aSlider.oninput = () => {
            document.getElementById('vA').textContent = aSlider.value;
            attractStrength = parseFloat(aSlider.value);
        };
        sSlider.oninput = () => {
            document.getElementById('vS').textContent = sSlider.value;
            objectScale = parseFloat(sSlider.value);
        };
        
        // Инициализация
        init();
        
        async function init() {
            if ('xr' in navigator) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        statusDiv.textContent = '✅ Quest AR готов! Настрой и нажми START.';
                        startBtn.textContent = 'START AR';
                        startBtn.disabled = false;
                        startBtn.onclick = startAR;
                    } else {
                        statusDiv.textContent = '❌ AR не поддерживается';
                        startBtn.textContent = 'AR НЕДОСТУПЕН';
                    }
                } catch(e) {
                    statusDiv.textContent = '❌ Ошибка проверки AR';
                }
            } else {
                statusDiv.textContent = '❌ WebXR не найден';
                startBtn.textContent = 'WEBXR НЕДОСТУПЕН';
            }
        }
        
        async function startAR() {
            try {
                const session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test'],
                });
                
                session.addEventListener('end', onSessionEnd);
                
                // Скрываем стартовый экран
                document.getElementById('startScreen').classList.add('hidden');
                
                setupScene(session);
                
            } catch(err) {
                alert('Ошибка запуска AR: ' + err.message);
            }
        }
        
        function setupScene(session) {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Reticle для размещения
            const reticleGeo = new THREE.RingGeometry(0.12, 0.18, 32).rotateX(-Math.PI / 2);
            const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(reticleGeo, reticleMat);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
            
            createQuantumField();
            
            renderer.xr.setSession(session);
            renderer.xr.setAnimationLoop(render);
        }
        
        function createQuantumField() {
            const field = new THREE.Group();
            field.visible = false;
            field.scale.set(objectScale, objectScale, objectScale);
            scene.add(field);
            window.field = field;
            
            // Каркас
            crystal = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 3.0, 0.3),
                new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.04, wireframe: true })
            );
            field.add(crystal);
            
            // Частицы
            particleColors = new Uint8Array(particleCount);
            velocities = new Float32Array(particleCount * 3);
            positions = new Float32Array(particleCount * 3);
            basePositions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) particleColors[i] = i % NUM_COLORS;
            updateParticleDistribution();
            
            const systems = [];
            for (let c = 0; c < NUM_COLORS; c++) {
                const col = COLOR_LIST[c];
                const cnt = Math.floor(particleCount / NUM_COLORS);
                const geo = new THREE.BufferGeometry();
                const cPos = new Float32Array(cnt * 3);
                let ci = 0;
                for (let i = 0; i < particleCount; i++) {
                    if (particleColors[i] === c && ci < cnt) {
                        cPos[ci * 3] = positions[i * 3];
                        cPos[ci * 3 + 1] = positions[i * 3 + 1];
                        cPos[ci * 3 + 2] = positions[i * 3 + 2];
                        ci++;
                    }
                }
                geo.setAttribute('position', new THREE.BufferAttribute(cPos, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.04,
                    map: makeTex(col[0] * 255, col[1] * 255, col[2] * 255),
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const pts = new THREE.Points(geo, mat);
                field.add(pts);
                systems.push({ pts, geo, cPos, colorIdx: c });
            }
            window.systems = systems;
            
            // Белое ядро
            corePositions = new Float32Array(CORE_COUNT * 3);
            coreBase = new Float32Array(CORE_COUNT * 3);
            coreVel = new Float32Array(CORE_COUNT * 3);
            buildCore();
            
            coreGeo = new THREE.BufferGeometry();
            coreGeo.setAttribute('position', new THREE.BufferAttribute(corePositions, 3));
            
            field.add(new THREE.Points(coreGeo, new THREE.PointsMaterial({
                size: 0.18, map: makeTex(220, 240, 255),
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.5
            })));
            field.add(new THREE.Points(coreGeo, new THREE.PointsMaterial({
                size: 0.09, map: makeTex(255, 255, 255),
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.9
            })));
            field.add(new THREE.Points(coreGeo, new THREE.PointsMaterial({
                size: 0.035, map: makeTex(255, 255, 255),
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 1.0
            })));
        }
        
        function makeTex(r, g, b) {
            const c = document.createElement('canvas');
            c.width = c.height = 32;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, `rgba(${r | 0},${g | 0},${b | 0},1)`);
            grad.addColorStop(0.4, `rgba(${r | 0},${g | 0},${b | 0},0.4)`);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(c);
        }
        
        function updateParticleDistribution() {
            for (let i = 0; i < particleCount; i++) {
                const t = i / particleCount;
                if (t < 0.45) {
                    const df = Math.pow(Math.random(), 3.75);
                    basePositions[i * 3] = (Math.random() - 0.5) * 4.4 * df;
                    basePositions[i * 3 + 1] = (Math.random() - 0.5) * 3.2;
                    basePositions[i * 3 + 2] = (Math.random() - 0.5) * 0.4;
                } else {
                    const df = Math.pow(Math.random(), 1.25);
                    const r = 2.2 * df;
                    const theta = Math.random() * 2 * Math.PI;
                    basePositions[i * 3] = r * Math.cos(theta) * 1.4;
                    basePositions[i * 3 + 1] = (Math.random() - 0.5) * 3.5;
                    basePositions[i * 3 + 2] = r * Math.sin(theta) * 0.6;
                }
                positions[i * 3] = basePositions[i * 3];
                positions[i * 3 + 1] = basePositions[i * 3 + 1];
                positions[i * 3 + 2] = basePositions[i * 3 + 2];
            }
        }
        
        function buildCore() {
            const w = 0.15;
            for (let i = 0; i < CORE_COUNT; i++) {
                const x = Math.random() - 0.5;
                coreBase[i * 3] = (x < 0 ? -1 : 1) * Math.pow(Math.abs(x), 1.5) * w * 2;
                coreBase[i * 3 + 1] = (Math.random() - 0.5) * 3.2;
                coreBase[i * 3 + 2] = (Math.random() - 0.5) * 0.15;
                corePositions[i * 3] = coreBase[i * 3];
                corePositions[i * 3 + 1] = coreBase[i * 3 + 1];
                corePositions[i * 3 + 2] = coreBase[i * 3 + 2];
            }
        }
        
        function render(timestamp, frame) {
            if (frame) {
                const refSpace = renderer.xr.getReferenceSpace();
                
                if (!hitTestSourceRequested) {
                    const session = renderer.xr.getSession();
                    session.requestReferenceSpace('viewer').then((viewerSpace) => {
                        session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    hitTestSourceRequested = true;
                }
                
                if (hitTestSource && !fieldPlaced) {
                    const results = frame.getHitTestResults(hitTestSource);
                    if (results.length) {
                        const hit = results[0];
                        reticle.visible = true;
                        const pose = hit.getPose(refSpace);
                        reticle.matrix.fromArray(pose.transform.matrix);
                    }
                } else {
                    reticle.visible = false;
                }
                
                // Размещение по нажатию
                const session = frame.session;
                for (const source of session.inputSources) {
                    if (source.gamepad?.buttons?.[0]?.pressed) {
                        if (!fieldPlaced && reticle.visible) {
                            window.field.position.setFromMatrixPosition(reticle.matrix);
                            window.field.visible = true;
                            fieldPlaced = true;
                            if (hitTestSource) {
                                hitTestSource.cancel();
                                hitTestSource = null;
                            }
                        }
                    }
                }
            }
            
            if (fieldPlaced) {
                time += 0.02;
                animateField();
            }
            
            renderer.render(scene, camera);
        }
        
        function animateField() {
            const attract = attractStrength;
            const amp = 0.25;
            const freq = 3.0;
            
            const centers = [
                { x: Math.sin(time * 0.7) * 0.4, y: 0.8 + Math.sin(time * 1.1) * 0.5 },
                { x: -1.2 + Math.sin(time * 0.9 + 1) * 0.3, y: Math.sin(time * 1.3) * 0.8 },
                { x: 1.2 + Math.sin(time * 0.9 + 2) * 0.3, y: Math.sin(time * 1.3 + Math.PI) * 0.8 },
                { x: Math.sin(time * 0.6 + 3) * 0.4, y: -0.8 + Math.sin(time) * 0.5 },
            ];
            
            for (let i = 0; i < particleCount; i++) {
                const bx = basePositions[i * 3];
                const by = basePositions[i * 3 + 1];
                const bz = basePositions[i * 3 + 2];
                const col = particleColors[i];
                
                const phase = by * freq + time * 3 + col * 1.57;
                const wave = Math.sin(phase) * amp;
                
                const dx = centers[col].x - positions[i * 3];
                const dy = centers[col].y - positions[i * 3 + 1];
                const dxCore = -positions[i * 3] * 0.08 * attract;
                
                velocities[i * 3] += dx * attract * 0.04 + dxCore;
                velocities[i * 3 + 1] += dy * attract * 0.04;
                velocities[i * 3] *= 0.88;
                velocities[i * 3 + 1] *= 0.88;
                velocities[i * 3 + 2] *= 0.88;
                
                positions[i * 3] = bx + wave + velocities[i * 3];
                positions[i * 3 + 1] = by + velocities[i * 3 + 1];
                positions[i * 3 + 2] = bz + velocities[i * 3 + 2];
            }
            
            window.systems.forEach(({ geo, cPos, colorIdx }) => {
                const cnt = Math.floor(particleCount / NUM_COLORS);
                let ci = 0;
                for (let i = 0; i < particleCount && ci < cnt; i++) {
                    if (particleColors[i] === colorIdx) {
                        cPos[ci * 3] = positions[i * 3];
                        cPos[ci * 3 + 1] = positions[i * 3 + 1];
                        cPos[ci * 3 + 2] = positions[i * 3 + 2];
                        ci++;
                    }
                }
                geo.attributes.position.needsUpdate = true;
            });
            
            // Белое ядро
            for (let i = 0; i < CORE_COUNT; i++) {
                const bx = coreBase[i * 3];
                const by = coreBase[i * 3 + 1];
                const bz = coreBase[i * 3 + 2];
                
                const phase = by * freq + time * 3.5;
                const wave = Math.sin(phase) * amp * 0.6;
                
                const dx = -corePositions[i * 3] * 0.075;
                const dy = (by - corePositions[i * 3 + 1]) * 0.05;
                
                coreVel[i * 3] += dx;
                coreVel[i * 3 + 1] += dy;
                coreVel[i * 3] *= 0.82;
                coreVel[i * 3 + 1] *= 0.85;
                coreVel[i * 3 + 2] *= 0.85;
                
                corePositions[i * 3] = bx + wave + coreVel[i * 3];
                corePositions[i * 3 + 1] = by + coreVel[i * 3 + 1];
                corePositions[i * 3 + 2] = bz + coreVel[i * 3 + 2];
            }
            coreGeo.attributes.position.needsUpdate = true;
            
            crystal.rotation.y += 0.003;
        }
        
        function onSessionEnd() {
            hitTestSourceRequested = false;
            hitTestSource = null;
            fieldPlaced = false;
            document.getElementById('startScreen').classList.remove('hidden');
        }
    </script>
</body>
</html>


